# 编译器开发记录

> by 王元淳 2019300099
>
> @NWPU chang'an 
>
> 参考https://pku-minic.github.io/online-doc/

## 1. 利用docker配置测试环境

Dockerfile:

https://hub.docker.com/layers/compiler-dev/maxxing/compiler-dev/latest/images/sha256-0dd7ee039b8db8e3ba67f23f144e885dc11962aa02ce970c16c13d6be1f15c7c?context=explore

此镜像中提供了RISC-V的测试环境

容器使用方式：

一次性方式：

```
docker run --rm maxxing/compiler-dev ls -l /
```

执行方式：(采用软连接指定可以实现让容器访问宿主机的文件)

```
docker run -it --rm -v /Users/frederickwang/Desktop/projects/compiler/compiler2022:/root/compiler maxxing/compiler-dev bash
```

## 2. IR选择（Koopa IR）

Koopa IR 是一种专为北京大学编译原理课程实践设计的教学用的中间表示 (IR), 它在设计上**类似 LLVM IR, 但简化了很多内容**, 方便大家上手和理解.

Koopa IR 是一种强类型的 IR, IR 中的所有值 (`Value`) 和函数 (`Function`) 都具备类型 (`Type`). 这种设计避免了一些 IR 定义上的模糊之处, 例如之前的教学用 IR 完全不区分整数变量和数组变量, 很容易出现混淆; 同时可以在生成 IR 之前就确定 IR 中存在的部分问题, 例如将任意整数作为内存地址并向其中存储数据.

Koopa IR 中, 基本块 (basic block) 必须是显式定义的. 即, 在描述函数内的指令时, 你必须把指令按照基本块分组, 每个基本块结尾的指令只能是分支/跳转/函数返回指令之一. 在 IR 的数据结构表示上, 指令也会被按照基本块分类. 这很大程度上方便了 IR 的优化, 因为许多优化算法都是在基本块的基础上对程序进行分析/变换的.

Koopa IR 还是一种 SSA 形式的 IR. 虽然这部分内容在课程实践中并非必须掌握, 但考虑到有些同学可能希望在课程实践的要求上, 做出一个更完备, 更强大的编译器, 我们将 Koopa IR 设计成了同时兼容非 SSA 形式和 SSA 形式的样子. 基于 SSA 形式下的 Koopa IR, 你可以开展更多复杂且有效的编译优化.

### LLVM IR：

LLVM：Low-Level Virtual Machine。LLVM项目本意是创建一个虚拟机。创建过程中，创立一个编译高效，占用资源较少的编译平台。从此LLVM代表了编译平台的含义。

![image-20220619090256306](编译器开发记录.assets/image-20220619090256306.png)

LLVM IR 的含义就是针对LLVM平台开发的IR：

<img src="编译器开发记录.assets/image-20220619090355041.png" alt="image-20220619090355041" style="zoom:50%;" />

LLVM IR有三种形式：

- 内存中的表示形式，如BasicBlock，Instruction这种cpp类；
- bitcode形式，这是一种序列化的二进制表示形式；
- LLVM汇编文件形式，这也是一种序列化的表示形式，与bitcode的区别是汇编文件是可读的、字符串的形式。

详细介绍：https://zhuanlan.zhihu.com/p/200613850

### SSA形式IR：

> In compiler design, static single assignment form (often abbreviated as SSA form or simply SSA) is a property of an intermediate representation (IR), which requires that each variable is assigned exactly once, and every variable is defined before it is used.

SSA 通过简化程序中变量的特性，可以同时达到两种目的：第一，可以简化很多编译优化方法的过程；第二，对很多编译优化方法来说，可以获得更好的优化结果。下面给出一个例子：

```
 y := 1
 y := 2
 x := y
```

SSA形式：

```
 y1 := 1
 y2 := 2
 x1 := y2
```

### Koopa IR执行实例

源码

```objc
// SysY 中的 `putch` 函数的声明.
decl @putch(i32)

// 一个用来输出字符串 (其实是整数数组) 的函数.
// 函数会扫描输入的数组, 将数组中的整数视作 ASCII 码, 并作为字符输出到屏幕上,
// 遇到 0 时停止扫描.
fun @putstr(@arr: *i32) {
%entry:
  jump %loop_entry(@arr)

// Koopa IR 采用基本块参数代替 SSA 形式中的 Phi 函数.
// 当然这部分内容并不在实践要求的必选内容之中, 你无需过分关注.
%loop_entry(%ptr: *i32):
  %cur = load %ptr
  br %cur, %loop_body, %end

%loop_body:
  call @putch(%cur)
  %next = getptr %ptr, 1
  jump %loop_entry(%next)

%end:
  ret
}

// 字符串 "Hello, world!\n\0".
global @str = alloc [i32, 15], {
  72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0
}

// `main` 函数, 程序的入口.
fun @main(): i32 {
%entry:
  %str = getelemptr @str, 0
  call @putstr(%str)
  ret 0
}

```



![image-20220619095350115](编译器开发记录.assets/image-20220619095350115.png)

## 3. RISC-V

RISC-V, 读作 “risk-five”, 是由加州大学伯克利分校设计并推广的第五代 RISC 指令系统体系结构 (ISA). RISC-V 没有任何历史包袱, 设计简洁, 高效低能耗, 且高度模块化——最主要的, 它还是一款完全开源的 ISA.

RISC-V 的指令系统由基础指令系统 (base instruction set) 和指令系统扩展 (extension) 构成. 每个 RISC-V 处理器必须实现基础指令系统, 同时可以支持若干扩展. 常用的基础指令系统有两种:

- `RV32I`: 32 位整数指令系统.
- `RV64I`: 64 位整数指令系统. 兼容 `RV32I`.

常用的标准指令系统扩展包括:

- `M` 扩展: 包括乘法和除法相关的指令.
- `A` 扩展: 包括原子内存操作相关的指令.
- `F` 扩展: 包括单精度浮点操作相关的指令.
- `D` 扩展: 包括双精度浮点操作相关的指令.
- `C` 扩展: 包括常用指令的 16 位宽度的压缩版本.

我们通常使用 `RV32/64I` + 扩展名称的方式来描述某个处理器/平台支持的 RISC-V 指令系统类型, 例如 `RV32IMA` 代表这个处理器是一个 32 位的, 支持 `M` 和 `A` 扩展的 RISC-V 处理器.

### RISC-V文件编译执行：

源码：

```objc
  # 代码段.
  .text
  # `main` 函数, 程序的入口.
  .globl main
main:
  addi  sp, sp, -16
  sw    ra, 12(sp)
  sw    s0, 8(sp)
  sw    s1, 4(sp)
  la    s0, hello_str
  li    s1, 0
1:
  add   a0, s0, s1
  lbu   a0, 0(a0)
  beqz  a0, 1f
  call  putch
  addi  s1, s1, 1
  j     1b
1:
  li    a0, 0
  lw    s1, 4(sp)
  lw    s0, 8(sp)
  lw    ra, 12(sp)
  addi  sp, sp, 16
  ret

  # 数据段.
  .data
  # 字符串 "Hello, world!\n\0".
hello_str:
  .asciz "Hello, world!\n"

```

![image-20220619100744760](编译器开发记录.assets/image-20220619100744760.png)

## 4. lv1: main函数处理

编译器把源代码变成可执行文件的过程 (通常) 又分为:

1. **编译:** 将源代码编译为汇编代码 (assembly).
2. **汇编:** 将汇编代码汇编为目标文件 (object file).
3. **链接:** 将目标文件链接为可执行文件 (execuatble).

我只涉及上述的第一点内容. 也就是, 我们只需要设计一个程序, 将输入的 SysY 源代码, 编译到 RISC-V 汇编即可. 在这种意义之下, 编译器通常由以下几个部分组成:

- **前端:** 通过词法分析和语法分析, 将源代码解析成抽象语法树 (abstract syntax tree, AST). 通过语义分析, 扫描抽象语法树, 检查其是否存在语义错误.
- **中端:** 将抽象语法树转换为中间表示 (intermediate representation, IR), 并在此基础上完成一些机器无关优化.
- **后端:** 将中间表示转换为目标平台的汇编代码, 并在此基础上完成一些机器相关优化.

### 编译器结构

源代码：

```c
int main() {
  // 我是注释诶嘿嘿
  return 0;
}
```

#### 词法分析器lexer

词法分析的作用, 是把字节流转换为单词流 (token stream). 词法分析器 (lexer) 会按照某种规则读取文件, 并将文件的内容拆分成一个个 token 作为输出, 传递给语法分析器 (parser). 同时, lexer 还会忽略文件里的一些无意义的内容, 比如**空格, 换行符和注释**.Lexer 生成的 token 会包含一些信息, 用来让 parser 区分 token 的种类, 以及在必要时获取 token 的内容.

1. **种类:** 关键字, **内容:** `int`.
2. **种类:** 标识符, **内容:** `main`.
3. **种类:** 其他字符, **内容:** `(`.
4. **种类:** 其他字符, **内容:** `)`.
5. **种类:** 其他字符, **内容:** `{`.
6. **种类:** 关键字, **内容:** `return`.
7. **种类:** 整数字面量, **内容:** `0`.
8. **种类:** 其他字符, **内容:** `;`.
9. **种类:** 其他字符, **内容:** `}`.

#### 语法分析器parser

Lexer 生成的 token 会包含一些信息, 用来让 parser 区分 token 的种类, 以及在必要时获取 token 的内容.

生成AST：

```c
CompUnit {
  items: [
    FuncDef {
      type: "int",
      name: "main",
      params: [],
      body: Block {
        stmts: [
          Return {
            value: 0
          }
        ]
      }
    }
  ]
}
```

#### 语义分析

语义分析阶段, 编译器通常会依据语义约束:

- **建立符号表**, 跟踪程序里变量的声明和使用, 确定程序在某处用到了哪一个变量, 同时也可发现变量重复定义/引用未定义变量之类的错误.
- **进行类型检查**, 确定程序中是否存在诸如 “对整数变量进行数组访问” 这种类型问题. 同时标注程序中表达式的类型, 以便进行后续的生成工作. 对于某些编程语言 (例如 C++11 之后的 C++, Rust 等等), 编译器还会进行类型推断.
- **进行必要的编译期计算**. SysY 中支持使用常量表达式作为数组定义时的长度, 而我们在生成 IR 之前, 必须知道数组的长度 (SysY 不支持 [VLA](https://en.wikipedia.org/wiki/Variable-length_array)), 这就要求编译器必须能在编译的时候算出常量表达式的值, 同时对那些无法计算的常量表达式报错. 对于某些支持元编程的语言, 这一步可能会非常复杂.

至此, 我们就能得到一个语法正确, 语义清晰的 AST 表示了.

#### IR生成

编译器通常不会直接通过扫描 AST 来生成目标代码 (汇编)——当然这么做也不是不可以, 因为从定义上讲, AST 也是一种 “中间表示”. 只不过, AST 在形式上更接近源语言, 而且其中可能会包含一些更为高级的语义, 例如分支/循环, 甚至结构体/类等等, 这些内容要一步到位变成汇编还是比较复杂的.

所以, 编译器通常会将 AST 转换为另一种形式的数据结构, 我们把它称作 IR. IR 的抽象层次比 AST 更低, 但又不至于低到汇编代码的程度. 在此基础上, 无论是直接把 IR 进一步转换为汇编代码, 还是在 IR 之上做出一些优化, 都相对更容易.

有了 IR 的存在, 我们也可以大幅降低编译器的开发成本: 假设我们想开发 MM 种语言的编译器, 要求它们能把输入编译成 NN 种指令系统的目标代码, 在没有统一的 IR 的情况下, 我们需要开发 M \times NM×N 个相关模块. 如果我们先把所有源语言都转换到同一种 IR, 然后再将这种 IR 翻译为不同的目标代码, 我们就只需要开发 M + NM+N 个相关模块.

现实世界的确存在这样的操作, 例如 [LLVM IR](https://llvm.org/docs/) 就是一种被广泛使用的 IR. 有很多语言的编译器实现, 例如 Rust, Swift, Julia, 都会将源语言翻译到 LLVM IR. 同时, LLVM IR 可被生成为 x86, ARM, RISC-V 等一系列指令系统的目标代码. 此时, 编译器的前后端是完全解耦的, 两部分可以各自维护, 十分方便.

此外, IR 也可以极大地方便开发者调试自己的编译器. 在编译实践中, 你的编译器对于同一个 SysY 文件的输入, 既可以输出 Koopa IR, 也可以输出 RISC-V. 你可以借助相关测试工具来测试这两部分的正确性, 进而定位你的编译器到底是在前端/中端部分出了问题, 还是在后端的部分出了问题.

当然, 和 token, AST 等数据结构一样, IR 作为编译器内部的一种表示, 其形式也并不是唯一的. 

#### 目标代码生成

编译器进行的最后一步操作, 就是将 IR 转换为目标代码, 也就是目标指令系统的汇编代码. 通常情况下, 这一步通常要做以下几件事:

1. **指令选择:** 决定 IR 中的指令应该被翻译为哪些目标指令系统的指令. 例如前文的 Koopa IR 程序中出现的 `lt` 指令可以被翻译为 RISC-V 中的 `slt`/`slti` 指令.
2. **寄存器分配:** 决定 IR 中的值和指令系统中寄存器的对应关系. 例如前文的 Koopa IR 程序中的 `@x`, `%cond`, `%0` 等等, 它们最终可能会被放在 RISC-V 的某些寄存器中. 由于指令系统中寄存器的数量通常是有限的 (RISC-V 中只有 32 个整数通用寄存器, 且它们并不都能用来存放数据), 某些值还可能会被分配在内存中.
3. **指令调度:** 决定 IR 生成的指令序列最终的顺序如何. 我们通常希望编译器能生成一个最优化的指令序列, 它可以最大程度地利用目标平台的微结构特性, 这样生成的程序的性能就会很高. 例如编译器可能会穿插调度访存指令和其他指令, 以求减少访存导致的停顿.

### 简单编译器实现

#### BENF

EBNF, 即 [Extended Backus–Naur Form](https://en.wikipedia.org/wiki/Extended_Backus–Naur_form), 扩展巴科斯范式, 可以用来描述编程语言的语法. 基于 SysY 的 EBNF, 我们可以从开始符号出发, 推导出任何一个符合 SysY 语法定义的 SysY 程序. 那么, 如何从上述的 EBNF 推导出示例的 SysY 程序呢?

我们不难注意到, EBNF 由若干条形如 `A ::= B;` 的规则构成. 这种规则告诉我们, 当我们遇到一个 `A` 时, 我们可以把 `A` 代换成 `B`, 这就完成了一次推导. 这其中, `A` 被称为非终结符, 因为它可以推导出其他的符号.

#### 开发模版

makefile模版https://github.com/pku-minic/sysy-make-template

#### sysy.l和sysy.y

在模板的 `src` 目录中新建两个文件: `sysy.l` 和 `sysy.y`, 前者将会描述**词法规则**并被 Flex 读取, 后者将会描述**语法规则**并被 Bison 读取. 由于 Flex 和 Bison 生成的 lexer 和 parser 会互相调用, 所以这两个文件里的内容也相互依赖.

`.l`/`.y` 文件有一些共同点, 比如它们的结构都是:

```cpp
// 这里写一些选项, 可以控制 Flex/Bison 的某些行为

%{

// 这里写一些全局的代码
// 因为最后要生成 C/C++ 文件, 实现主要逻辑的部分都是用 C/C++ 写的
// 难免会用到头文件, 所以通常  头文件和一些全局声明/定义  写在这里

%}

// 这里写一些 Flex/Bison 相关的  定义
// 对于 Flex, 这里可以定义某个符号对应的正则表达式
// 对于 Bison, 这里可以定义终结符/非终结符的类型

%%

// 这里写 Flex/Bison 的  规则描述
// 对于 Flex, 这里写的是 lexer 扫描到某个 token 后做的操作
// 对于 Bison, 这里写的是 parser 遇到某种语法规则后做的操作

%%

// 这里写一些用户  自定义的代码
// 比如你希望在生成的 C/C++ 文件里定义一个函数, 做一些辅助工作
// 你同时希望在之前的规则描述里调用你定义的函数
// 那么, 你可以把 C/C++ 的函数定义写在这里, 声明写在文件开头
```

在目录中利用MakeFile进行编译：

```makefile
# Based on https://matansilver.com/2017/08/29/universal-makefile/
# Modified by MaxXing

# Settings
# Set to 0 to enable C mode
CPP_MODE := 1
ifeq ($(CPP_MODE), 0)
FB_EXT := .c
else
FB_EXT := .cpp
endif

# Flags
CFLAGS := -Wall -std=c11
CXXFLAGS := -Wall -Wno-register -std=c++17
FFLAGS :=
BFLAGS := -d
LDFLAGS :=

# Debug flags
DEBUG ?= 1
ifeq ($(DEBUG), 0)
CFLAGS += -O2
CXXFLAGS += -O2
else
CFLAGS += -g -O0
CXXFLAGS += -g -O0
endif

# Compilers
CC := clang
CXX := clang++
FLEX := flex
BISON := bison

# Directories
TOP_DIR := $(shell pwd)
TARGET_EXEC := compiler
SRC_DIR := $(TOP_DIR)/src
BUILD_DIR ?= $(TOP_DIR)/build
LIB_DIR ?= $(CDE_LIBRARY_PATH)/native
INC_DIR ?= $(CDE_INCLUDE_PATH)
CFLAGS += -I$(INC_DIR)
CXXFLAGS += -I$(INC_DIR)
LDFLAGS += -L$(LIB_DIR) -lkoopa

# Source files & target files
FB_SRCS := $(patsubst $(SRC_DIR)/%.l, $(BUILD_DIR)/%.lex$(FB_EXT), $(shell find $(SRC_DIR) -name "*.l"))
FB_SRCS += $(patsubst $(SRC_DIR)/%.y, $(BUILD_DIR)/%.tab$(FB_EXT), $(shell find $(SRC_DIR) -name "*.y"))
SRCS := $(FB_SRCS) $(shell find $(SRC_DIR) -name "*.c" -or -name "*.cpp" -or -name "*.cc")
OBJS := $(patsubst $(SRC_DIR)/%.c, $(BUILD_DIR)/%.c.o, $(SRCS))
OBJS := $(patsubst $(SRC_DIR)/%.cpp, $(BUILD_DIR)/%.cpp.o, $(OBJS))
OBJS := $(patsubst $(SRC_DIR)/%.cc, $(BUILD_DIR)/%.cc.o, $(OBJS))
OBJS := $(patsubst $(BUILD_DIR)/%.c, $(BUILD_DIR)/%.c.o, $(OBJS))
OBJS := $(patsubst $(BUILD_DIR)/%.cpp, $(BUILD_DIR)/%.cpp.o, $(OBJS))
OBJS := $(patsubst $(BUILD_DIR)/%.cc, $(BUILD_DIR)/%.cc.o, $(OBJS))

# Header directories & dependencies
INC_DIRS := $(shell find $(SRC_DIR) -type d)
INC_DIRS += $(INC_DIRS:$(SRC_DIR)%=$(BUILD_DIR)%)
INC_FLAGS := $(addprefix -I, $(INC_DIRS))
DEPS := $(OBJS:.o=.d)
CPPFLAGS = $(INC_FLAGS) -MMD -MP


# Main target
$(BUILD_DIR)/$(TARGET_EXEC): $(FB_SRCS) $(OBJS)
	$(CXX) $(OBJS) $(LDFLAGS) -lpthread -ldl -o $@

# C source
define c_recipe
	mkdir -p $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
endef
$(BUILD_DIR)/%.c.o: $(SRC_DIR)/%.c; $(c_recipe)
$(BUILD_DIR)/%.c.o: $(BUILD_DIR)/%.c; $(c_recipe)

# C++ source
define cxx_recipe
	mkdir -p $(dir $@)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@
endef
$(BUILD_DIR)/%.cpp.o: $(SRC_DIR)/%.cpp; $(cxx_recipe)
$(BUILD_DIR)/%.cpp.o: $(BUILD_DIR)/%.cpp; $(cxx_recipe)
$(BUILD_DIR)/%.cc.o: $(SRC_DIR)/%.cc; $(cxx_recipe)

# Flex
$(BUILD_DIR)/%.lex$(FB_EXT): $(SRC_DIR)/%.l
	mkdir -p $(dir $@)
	$(FLEX) $(FFLAGS) -o $@ $<

# Bison
$(BUILD_DIR)/%.tab$(FB_EXT): $(SRC_DIR)/%.y
	mkdir -p $(dir $@)
	$(BISON) $(BFLAGS) -o $@ $<


.PHONY: clean

clean:
	-rm -rf $(BUILD_DIR)

-include $(DEPS)

```

执行结果：（单纯返回源程序中的字符串）

![image-20220622003334476](编译器开发记录.assets/image-20220622003334476.png)

#### AST

前端通过词法分析和语法分析, 将源代码解析成抽象语法树 (abstract syntax tree, AST)，通过语义分析，扫描AST，检查是否存在语义错误。

1. AST 保留了程序语法的结构.
2. AST 是为了方便程序的处理而存在的, 不存在什么设计规范.

AST 需要保留一些必要的语法结构. 或者换句话说, EBNF 长什么样, AST 就可以长什么样. 比如本章需要大家处理的 EBNF 如下:

```bison
CompUnit  ::= FuncDef;

FuncDef   ::= FuncType IDENT "(" ")" Block;
FuncType  ::= "int";

Block     ::= "{" Stmt "}";
Stmt      ::= "return" Number ";";
Number    ::= INT_CONST;

```

那么bison的设计就应该是：

```cpp
struct CompUnit {
  FuncDef func_def;
};

struct FuncDef {
  FuncType func_type;
  std::string ident;
  Block block;
};

```

用面向对象以及智能指针来优化：

```cpp
// 所有 AST 的基类
class BaseAST {
 public:
  virtual ~BaseAST() = default;
};

// CompUnit 是 BaseAST
class CompUnitAST : public BaseAST {
 public:
  // 用智能指针管理对象
  std::unique_ptr<BaseAST> func_def;
};

// FuncDef 也是 BaseAST
class FuncDefAST : public BaseAST {
 public:
  std::unique_ptr<BaseAST> func_type;
  std::string ident;
  std::unique_ptr<BaseAST> block;
};

// ...

```

#### Koopa IR基础

结构：

Koopa IR 中, 最大的单位是 `Program`, 它代表一个 Koopa IR 程序. `Program` 由若干全局变量 (`Value`) 和函数 (`Function`) 构成. `Function` 又由若干基本块 (`BasicBlock`) 构成, 基本块中是一系列指令, 指令也是 `Value`. 所以 Koopa IR 程序的结构如下所示:

```
Program
	全局变量列表:
		Value 1.
		Value 2.
		…
	函数列表:
		Function 1.
			基本块列表:
				BasicBlock 1.
					指令列表:
            Value 1.
            Value 2.
						…
				BasicBlock 2.
				…
		Function 2.
		…
```

#### 基本块

基本块 ([basic block](https://en.wikipedia.org/wiki/Basic_block)) 是编译领域的一个很常见的概念, 它指的是一系列指令的集合, 基本块满足:

- **只有一个入口点:** 所有基本块中的指令如果要执行跳转, 只能跳到某个基本块的开头, 而不能跳到中间.
- **只有一个出口点:** 基本块中, 只有最后一条指令能进行控制流的转移, 也就是跳到其他基本块, 或者从函数中返回 (执行 `return` 操作).

基本块的存在可以简化很多编译过程中需要进行的分析, 所以 Koopa IR 要求函数中的指令必须预先按照基本块分类. 同时, Koopa IR 约定, 函数的第一个基本块为函数的入口基本块, 也就是执行函数时, 首先会执行第一个基本块中的指令.

现阶段, 我们可以暂时忽略全局变量, 同时我们也可以暂时认为, `Program` 的函数列表里只有一个 `Function`, `Function` 的基本块列表里只有一个 `BasicBlock` (也就是入口基本块).

接下来, 基本块中必须存在指令, 也就是 `Value`. Koopa IR 中主要有以下几种 `Value` (详见 [`ValueKind` 的文档](https://docs.rs/koopa/latest/koopa/ir/entities/enum.ValueKind.html)):

- **各类常量:** 整数常量 (`Integer`), 零初始化器 (`ZeroInit`), 等等.
- **参数引用:** 函数参数引用 (`FuncArgRef`) 等, 用来指代传入的参数.
- **内存分配:** 全局内存分配 (`GlobalAlloc`, 所有的全局变量都是这个玩意) 和局部内存分配 (`Alloc`).
- **访存指令:** 加载 (`Load`) 和存储 (`Store`).
- **指针运算:** `GetPtr` 和 `GetElemPtr`.
- **二元运算:** `Binary`, 比如加减乘除模/比较之类的运算都属于此类.
- **控制转移:** 条件分支 (`Branch`) 和无条件跳转 (`Jump`).
- **函数相关:** 函数调用 (`Call`) 和函数返回 (`Return`).

#### Koopa IR 生成思路

有以下几种生成 IR 的思路:

- 遍历 AST, 输出文本形式的 IR. 这样最简单, 适用于任何语言实现的编译器.
- 调用 Koopa IR 框架提供的接口. 使用 Rust 的同学可以尝试, 详见 Koopa IR 框架的 [crates.io](https://crates.io/crates/koopa) 以及[文档](https://docs.rs/koopa).
- 像定义 AST 一样定义表示 Koopa IR 的数据结构 (比如指令/基本块/函数等等), 然后遍历 AST 输出这种结构, 再遍历这种结构输出字符串.
- 对于使用 C/C++ 的同学, 在上一条的基础上, 你可以考虑把这种结构转换成 raw program, 然后使用 `libkoopa` 中的相关接口, 将 raw program 转换成其他形式的 Koopa IR 程序.

#### Koopa IR实现

koopa.h

```h
#ifndef LIBKOOPA_KOOPA_H_
#define LIBKOOPA_KOOPA_H_

#include <stddef.h>
#include <stdint.h>
#if defined(_WIN32) || defined(_WIN64)
#define KOOPA_OS_WINDOWS
#include <Windows.h>
#endif

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

    ///
    /// Error code of some Koopa functions.
    ///
    enum koopa_error_code
    {
        /// No errors occurred.
        KOOPA_EC_SUCCESS = 0,
        /// UTF-8 string conversion error.
        KOOPA_EC_INVALID_UTF8_STRING,
        /// File operation error.
        KOOPA_EC_INVALID_FILE,
        /// Koopa IR program parsing error.
        KOOPA_EC_INVALID_KOOPA_PROGRAM,
        /// IO operation error.
        KOOPA_EC_IO_ERROR,
        /// Byte array to C string conversion error.
        KOOPA_EC_NULL_BYTE_ERROR,
        /// Insufficient buffer length.
        KOOPA_EC_INSUFFICIENT_BUFFER_LENGTH,
        /// Mismatch of item kind in raw slice.
        KOOPA_EC_RAW_SLICE_ITEM_KIND_MISMATCH,
        /// Passing null pointers to `libkoopa`.
        KOOPA_EC_NULL_POINTER_ERROR,
        /// Mismatch of type.
        KOOPA_EC_TYPE_MISMATCH,
        /// Mismatch of function parameter number.
        KOOPA_EC_FUNC_PARAM_NUM_MISMATCH,
    };

    ///
    /// Type of error code.
    ///
    typedef int32_t koopa_error_code_t;

///
/// Raw file (file descriptor or handle).
///
#ifdef KOOPA_OS_WINDOWS
    typedef HANDLE koopa_raw_file_t;
#else
typedef int koopa_raw_file_t;
#endif

    ///
    /// Koopa IR program.
    ///
    typedef const void *koopa_program_t;

    ///
    /// Raw program builder.
    ///
    typedef void *koopa_raw_program_builder_t;

    ///
    /// Kind of raw slice item.
    ///
    enum koopa_raw_slice_item_kind
    {
        /// Unknown.
        KOOPA_RSIK_UNKNOWN = 0,
        /// Type.
        KOOPA_RSIK_TYPE,
        /// Function.
        KOOPA_RSIK_FUNCTION,
        /// Basic block.
        KOOPA_RSIK_BASIC_BLOCK,
        /// Value.
        KOOPA_RSIK_VALUE,
    };

    ///
    /// Type of raw slice item kind.
    ///
    typedef uint32_t koopa_raw_slice_item_kind_t;

    ///
    /// A raw slice that can store any kind of items.
    ///
    typedef struct
    {
        /// Buffer of slice items.
        const void **buffer;
        /// Length of slice.
        uint32_t len;
        /// Kind of slice items.
        koopa_raw_slice_item_kind_t kind;
    } koopa_raw_slice_t;

    ///
    /// Tag of raw Koopa type.
    ///
    typedef enum
    {
        /// 32-bit integer.
        KOOPA_RTT_INT32,
        /// Unit (void).
        KOOPA_RTT_UNIT,
        /// Array (with base type and length).
        KOOPA_RTT_ARRAY,
        /// Pointer (with base type).
        KOOPA_RTT_POINTER,
        /// Function (with parameter types and return type).
        KOOPA_RTT_FUNCTION,
    } koopa_raw_type_tag_t;

    ///
    /// Kind of raw Koopa type.
    ///
    typedef struct koopa_raw_type_kind
    {
        koopa_raw_type_tag_t tag;
        union
        {
            struct
            {
                const struct koopa_raw_type_kind *base;
                size_t len;
            } array;
            struct
            {
                const struct koopa_raw_type_kind *base;
            } pointer;
            struct
            {
                koopa_raw_slice_t params;
                const struct koopa_raw_type_kind *ret;
            } function;
        } data;
    } koopa_raw_type_kind_t;

    ///
    /// A raw Koopa type.
    ///
    typedef const koopa_raw_type_kind_t *koopa_raw_type_t;

    ///
    /// A raw Koopa program.
    ///
    typedef struct
    {
        /// Global values (global allocations only).
        koopa_raw_slice_t values;
        /// Function definitions.
        koopa_raw_slice_t funcs;
    } koopa_raw_program_t;

    ///
    /// Data of raw Koopa function.
    ///
    typedef struct
    {
        /// Type of function.
        koopa_raw_type_t ty;
        /// Name of function.
        const char *name;
        /// Parameters.
        koopa_raw_slice_t params;
        /// Basic blocks, empty if is a function declaration.
        koopa_raw_slice_t bbs;
    } koopa_raw_function_data_t;

    ///
    /// A raw Koopa function.
    ///
    typedef const koopa_raw_function_data_t *koopa_raw_function_t;

    ///
    /// Data of raw Koopa basic block.
    ///
    typedef struct
    {
        /// Name of basic block, null if no name.
        const char *name;
        /// Parameters.
        koopa_raw_slice_t params;
        /// Values that this basic block is used by.
        koopa_raw_slice_t used_by;
        /// Instructions in this basic block.
        koopa_raw_slice_t insts;
    } koopa_raw_basic_block_data_t;

    ///
    /// A raw Koopa basic block.
    ///
    typedef const koopa_raw_basic_block_data_t *koopa_raw_basic_block_t;

    struct koopa_raw_value_data;

    ///
    /// Data of raw Koopa value.
    ///
    typedef struct koopa_raw_value_data koopa_raw_value_data_t;

    ///
    /// A raw Koopa value.
    ///
    typedef const koopa_raw_value_data_t *koopa_raw_value_t;

    ///
    /// Raw integer constant.
    ///
    typedef struct
    {
        /// Value of integer.
        int32_t value;
    } koopa_raw_integer_t;

    ///
    /// Raw aggregate constant.
    ///
    typedef struct
    {
        /// Elements.
        koopa_raw_slice_t elems;
    } koopa_raw_aggregate_t;

    ///
    /// Raw function argument reference.
    ///
    typedef struct
    {
        /// Index.
        size_t index;
    } koopa_raw_func_arg_ref_t;

    ///
    /// Raw basic block argument reference.
    ///
    typedef struct
    {
        /// Index.
        size_t index;
    } koopa_raw_block_arg_ref_t;

    ///
    /// Raw global memory allocation.
    ///
    typedef struct
    {
        /// Initializer.
        koopa_raw_value_t init;
    } koopa_raw_global_alloc_t;

    ///
    /// Raw memory load.
    ///
    typedef struct
    {
        /// Source.
        koopa_raw_value_t src;
    } koopa_raw_load_t;

    ///
    /// Raw memory store.
    ///
    typedef struct
    {
        /// Value.
        koopa_raw_value_t value;
        /// Destination.
        koopa_raw_value_t dest;
    } koopa_raw_store_t;

    ///
    /// Raw pointer calculation.
    ///
    typedef struct
    {
        /// Source.
        koopa_raw_value_t src;
        /// Index.
        koopa_raw_value_t index;
    } koopa_raw_get_ptr_t;

    ///
    /// Raw element pointer calculation.
    ///
    typedef struct
    {
        /// Source.
        koopa_raw_value_t src;
        /// Index.
        koopa_raw_value_t index;
    } koopa_raw_get_elem_ptr_t;

    ///
    /// Raw binary operator.
    ///
    enum koopa_raw_binary_op
    {
        /// Not equal to.
        KOOPA_RBO_NOT_EQ,
        /// Equal to.
        KOOPA_RBO_EQ,
        /// Greater than.
        KOOPA_RBO_GT,
        /// Less than.
        KOOPA_RBO_LT,
        /// Greater than or equal to.
        KOOPA_RBO_GE,
        /// Less than or equal to.
        KOOPA_RBO_LE,
        /// Addition.
        KOOPA_RBO_ADD,
        /// Subtraction.
        KOOPA_RBO_SUB,
        /// Multiplication.
        KOOPA_RBO_MUL,
        /// Division.
        KOOPA_RBO_DIV,
        /// Modulo.
        KOOPA_RBO_MOD,
        /// Bitwise AND.
        KOOPA_RBO_AND,
        /// Bitwise OR.
        KOOPA_RBO_OR,
        /// Bitwise XOR.
        KOOPA_RBO_XOR,
        /// Shift left logical.
        KOOPA_RBO_SHL,
        /// Shift right logical.
        KOOPA_RBO_SHR,
        /// Shift right arithmetic.
        KOOPA_RBO_SAR,
    };

    ///
    /// Type of raw binary operator.
    ///
    typedef uint32_t koopa_raw_binary_op_t;

    ///
    /// Raw binary operation.
    ///
    typedef struct
    {
        /// Operator.
        koopa_raw_binary_op_t op;
        /// Left-hand side value.
        koopa_raw_value_t lhs;
        /// Right-hand side value.
        koopa_raw_value_t rhs;
    } koopa_raw_binary_t;

    ///
    /// Raw conditional branch.
    ///
    typedef struct
    {
        /// Condition.
        koopa_raw_value_t cond;
        /// Target if condition is `true`.
        koopa_raw_basic_block_t true_bb;
        /// Target if condition is `false`.
        koopa_raw_basic_block_t false_bb;
        /// Arguments of `true` target..
        koopa_raw_slice_t true_args;
        /// Arguments of `false` target..
        koopa_raw_slice_t false_args;
    } koopa_raw_branch_t;

    ///
    /// Raw unconditional jump.
    ///
    typedef struct
    {
        /// Target.
        koopa_raw_basic_block_t target;
        /// Arguments of target..
        koopa_raw_slice_t args;
    } koopa_raw_jump_t;

    ///
    /// Raw function call.
    ///
    typedef struct
    {
        /// Callee.
        koopa_raw_function_t callee;
        /// Arguments.
        koopa_raw_slice_t args;
    } koopa_raw_call_t;

    ///
    /// Raw function return.
    ///
    typedef struct
    {
        /// Return value, null if no return value.
        koopa_raw_value_t value;
    } koopa_raw_return_t;

    ///
    /// Tag of raw Koopa value.
    ///
    typedef enum
    {
        /// Integer constant.
        KOOPA_RVT_INTEGER,
        /// Zero initializer.
        KOOPA_RVT_ZERO_INIT,
        /// Undefined value.
        KOOPA_RVT_UNDEF,
        /// Aggregate constant.
        KOOPA_RVT_AGGREGATE,
        /// Function argument reference.
        KOOPA_RVT_FUNC_ARG_REF,
        /// Basic block argument reference.
        KOOPA_RVT_BLOCK_ARG_REF,
        /// Local memory allocation.
        KOOPA_RVT_ALLOC,
        /// Global memory allocation.
        KOOPA_RVT_GLOBAL_ALLOC,
        /// Memory load.
        KOOPA_RVT_LOAD,
        /// Memory store.
        KOOPA_RVT_STORE,
        /// Pointer calculation.
        KOOPA_RVT_GET_PTR,
        /// Element pointer calculation.
        KOOPA_RVT_GET_ELEM_PTR,
        /// Binary operation.
        KOOPA_RVT_BINARY,
        /// Conditional branch.
        KOOPA_RVT_BRANCH,
        /// Unconditional jump.
        KOOPA_RVT_JUMP,
        /// Function call.
        KOOPA_RVT_CALL,
        /// Function return.
        KOOPA_RVT_RETURN,
    } koopa_raw_value_tag_t;

    ///
    /// Kind of raw Koopa value.
    ///
    typedef struct
    {
        koopa_raw_value_tag_t tag;
        union
        {
            koopa_raw_integer_t integer;
            koopa_raw_aggregate_t aggregate;
            koopa_raw_func_arg_ref_t func_arg_ref;
            koopa_raw_block_arg_ref_t block_arg_ref;
            koopa_raw_global_alloc_t global_alloc;
            koopa_raw_load_t load;
            koopa_raw_store_t store;
            koopa_raw_get_ptr_t get_ptr;
            koopa_raw_get_elem_ptr_t get_elem_ptr;
            koopa_raw_binary_t binary;
            koopa_raw_branch_t branch;
            koopa_raw_jump_t jump;
            koopa_raw_call_t call;
            koopa_raw_return_t ret;
        } data;
    } koopa_raw_value_kind_t;

    struct koopa_raw_value_data
    {
        /// Type of value.
        koopa_raw_type_t ty;
        /// Name of value, null if no name.
        const char *name;
        /// Values that this value is used by.
        koopa_raw_slice_t used_by;
        /// Kind of value.
        koopa_raw_value_kind_t kind;
    };

    ///
    /// Parses text-form Koopa IR program from the given file.
    /// Updates the `program` if no errors occurred.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_parse_from_file(const char *path,
                                             koopa_program_t *program);

    ///
    /// Parses text-form Koopa IR program from the given string.
    /// Updates the `program` if no errors occurred.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_parse_from_string(const char *str,
                                               koopa_program_t *program);

    ///
    /// Parses text-form Koopa IR program from the standard input.
    /// Updates the `program` if no errors occurred.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_parse_from_stdin(koopa_program_t *program);

    ///
    /// Parses text-form Koopa IR program from the given
    /// file descriptor (UNIX) or handle (Windows).
    /// Updates the `program` if no errors occurred.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_parse_from_raw(koopa_raw_file_t file,
                                            koopa_program_t *program);

    ///
    /// Deletes the given program.
    ///
    /// All programs returned by Koopa IR library functions
    /// should be deleted manually.
    ///
    void koopa_delete_program(koopa_program_t program);

    ///
    /// Generates text-form Koopa IR program to the given file.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_to_file(koopa_program_t program,
                                          const char *path);

    ///
    /// Generates a null-terminated string of text-form Koopa IR program
    /// to the given buffer. If the given buffer is null, updates the `len`
    /// to the length of the generated string (with out the null-terminator).
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_to_string(koopa_program_t program,
                                            char *buffer, size_t *len);

    ///
    /// Generates text-form Koopa IR program to the standard output.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_to_stdout(koopa_program_t program);

    ///
    /// Generates text-form Koopa IR program to the given
    /// file descriptor (UNIX) or handle (Windows).
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_to_raw(koopa_program_t program,
                                         koopa_raw_file_t file);

    ///
    /// Generates LLVM IR to the given file.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_llvm_to_file(koopa_program_t program,
                                               const char *path);

    ///
    /// Generates a null-terminated string of LLVM IR to the given buffer.
    /// If the given buffer is null, updates the `len` to the length of
    /// the generated string (with out the null-terminator).
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_llvm_to_string(koopa_program_t program,
                                                 char *buffer, size_t *len);

    ///
    /// Generates LLVM IR to the standard output.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_llvm_to_stdout(koopa_program_t program);

    ///
    /// Generates LLVM IR to the given
    /// file descriptor (UNIX) or handle (Windows).
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_dump_llvm_to_raw(koopa_program_t program,
                                              koopa_raw_file_t file);

    ///
    /// Creates a new raw program builder. Returns its pointer.
    ///
    koopa_raw_program_builder_t koopa_new_raw_program_builder();

    ///
    /// Frees allocated memory of the given raw program builder.
    ///
    void koopa_delete_raw_program_builder(koopa_raw_program_builder_t builder);

    ///
    /// Builds a raw program of the given Koopa IR program
    /// using the given raw program builder.
    ///
    /// The generated raw program is valid iff the raw program builder
    /// is still alive (not deleted). The generated raw program should
    /// not be modified manually.
    ///
    koopa_raw_program_t koopa_build_raw_program(
        koopa_raw_program_builder_t builder, koopa_program_t program);

    ///
    /// Generates the given raw program to the Koopa IR program.
    /// Updates the `program` if no errors occurred.
    ///
    /// Returns the error code.
    ///
    koopa_error_code_t koopa_generate_raw_to_koopa(
        const koopa_raw_program_t *raw, koopa_program_t *program);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif // LIBKOOPA_KOOPA_H_
```

## 5. Lv2: 目标代码生成

能够处理带有注释的返回代码

```cpp
int main() {
  // 摊牌了, 我是注释
  return 0;
}
```

### Koopa IR处理

对于从AST到Koopa IR，可能会采用两种思路完成这一操作:

1. 遍历 AST, 输出文本形式的 Koopa IR 程序.
2. 遍历 AST, 直接建立 (某种) 内存形式的 Koopa IR, 再将其转换为文本形式输出.

对于**第二种思路**, 无论你是通过阅读 Koopa IR 的[文档](https://docs.rs/koopa), 直接建立了内存形式 IR, 还是根据[Koopa IR 规范](https://pku-minic.github.io/online-doc/#/misc-app-ref/koopa), 自行设计了一套数据结构来表示 Koopa IR 程序, 你其实都已经得到了一个可被你程序处理的内存形式的 Koopa IR. 在目标代码生成阶段, 你可以直接让你的编译器遍历这些数据结构, 并生成代码. 

**第一种思路**相当简单且直观, 实现难度很低. 但其缺点是, 你在生成目标代码之前, 不得不再次将文本形式的 Koopa IR 转换成某种数据结构——这相当于再写一个编译器. 否则, 你的程序几乎无法直接基于文本形式 IR 生成汇编.

教程提供了能够处理 Koopa IR 的库, 可以使用其中的实现, 来将文本形式的 IR 转换为内存形式.

#### 将文本形式的Koopa IR转化为内存形式：

首先引用koopa.h头文件

```c
// 解析字符串 str, 得到 Koopa IR 程序
koopa_program_t program;
koopa_error_code_t ret = koopa_parse_from_string(str, &program);
assert(ret == KOOPA_EC_SUCCESS);  // 确保解析时没有出错
// 创建一个 raw program builder, 用来构建 raw program
koopa_raw_program_builder_t builder = koopa_new_raw_program_builder();
// 将 Koopa IR 程序转换为 raw program
koopa_raw_program_t raw = koopa_build_raw_program(builder, program);
// 释放 Koopa IR 程序占用的内存
koopa_delete_program(program);

// 处理 raw program
// ...

// 处理完成, 释放 raw program builder 占用的内存
// 注意, raw program 中所有的指针指向的内存均为 raw program builder 的内存
// 所以不要在 raw program 处理完毕之前释放 builder
koopa_delete_raw_program_builder(builder);

```

其中, raw program 的结构和 Lv1 中提到的 Koopa IR 程序的结构完全一致:

- 最上层是 `koopa_raw_program_t`, 也就是 `Program`.
- 之下是全局变量定义列表和函数定义列表.
  - 在 raw program 中, 列表的类型是 `koopa_raw_slice_t`.
  - 本质上这是一个指针数组, 其中的 `buffer` 字段记录了指针数组的地址 (类型是 `const void **`), `len` 字段记录了指针数组的长度, `kind` 字段记录了数组元素是何种类型的指针
  - 在访问时, 你可以通过 `slice.buffer[i]` 拿到列表元素的指针, 然后通过判断 `kind` 来决定把这个指针转换成什么类型.
- `koopa_raw_function_t` 代表函数, 其中是基本块列表.
- `koopa_raw_basic_block_t` 代表基本块, 其中是指令列表.
- `koopa_raw_value_t` 代表全局变量, 或者基本块中的指令.

#### 进一步处理内存中的Koopa IR

遍历函数列表：

```c
koopa_raw_program_t raw = ...;
// 使用 for 循环遍历函数列表
for (size_t i = 0; i < raw.funcs.len; ++i) {
  // 正常情况下, 列表中的元素就是函数, 我们只不过是在确认这个事实
  // 当然, 你也可以基于 raw slice 的 kind, 实现一个通用的处理函数
  assert(raw.funcs.kind == KOOPA_RSIK_FUNCTION);
  // 获取当前函数
  koopa_raw_function_t func = (koopa_raw_function_t) raw.funcs.buffer[i];
  // 进一步处理当前函数
  // ...
}
```

遍历函数中的基本块：

```c
for (size_t j = 0; j < func->bbs.len; ++j) {
  assert(func->bbs.kind == KOOPA_RSIK_BASIC_BLOCK);
  koopa_raw_basic_block_t bb = (koopa_raw_basic_block_t) func->bbs.buffer[j];
  // 进一步处理当前基本块
  // ...
}
```

遍历得到value：

```c
koopa_raw_value_t value = ...;
// 示例程序中, 你得到的 value 一定是一条 return 指令
assert(value->kind.tag == KOOPA_RVT_RETURN);
// 于是我们可以按照处理 return 指令的方式处理这个 value
// return 指令中, value 代表返回值
koopa_raw_value_t ret_value = value->kind.data.ret.value;
// 示例程序中, ret_value 一定是一个 integer
assert(ret_value->kind.tag == KOOPA_RVT_INTEGER);
// 于是我们可以按照处理 integer 的方式处理 ret_value
// integer 中, value 代表整数的数值
int32_t int_val = ret_value->kind.data.integer.value;
// 示例程序中, 这个数值一定是 0
assert(int_val == 0);
```

总结/利用DFS处理整个文件：

```cpp
// 函数声明略
// ...

// 访问 raw program
void Visit(const koopa_raw_program_t &program) {
  // 执行一些其他的必要操作
  // ...
  // 访问所有全局变量
  Visit(program.values);
  // 访问所有函数
  Visit(program.funcs);
}

// 访问 raw slice
void Visit(const koopa_raw_slice_t &slice) {
  for (size_t i = 0; i < slice.len; ++i) {
    auto ptr = slice.buffer[i];
    // 根据 slice 的 kind 决定将 ptr 视作何种元素
    switch (slice.kind) {
      case KOOPA_RSIK_FUNCTION:
        // 访问函数
        Visit(reinterpret_cast<koopa_raw_function_t>(ptr));
        break;
      case KOOPA_RSIK_BASIC_BLOCK:
        // 访问基本块
        Visit(reinterpret_cast<koopa_raw_basic_block_t>(ptr));
        break;
      case KOOPA_RSIK_VALUE:
        // 访问指令
        Visit(reinterpret_cast<koopa_raw_value_t>(ptr));
        break;
      default:
        // 我们暂时不会遇到其他内容, 于是不对其做任何处理
        assert(false);
    }
  }
}

// 访问函数
void Visit(const koopa_raw_function_t &func) {
  // 执行一些其他的必要操作
  // ...
  // 访问所有基本块
  Visit(func->bbs);
}

// 访问基本块
void Visit(const koopa_raw_basic_block_t &bb) {
  // 执行一些其他的必要操作
  // ...
  // 访问所有指令
  Visit(bb->insts);
}

// 访问指令
void Visit(const koopa_raw_value_t &value) {
  // 根据指令类型判断后续需要如何访问
  const auto &kind = value->kind;
  switch (kind.tag) {
    case KOOPA_RVT_RETURN:
      // 访问 return 指令
      Visit(kind.data.ret);
      break;
    case KOOPA_RVT_INTEGER:
      // 访问 integer 指令
      Visit(kind.data.integer);
      break;
    default:
      // 其他类型暂时遇不到
      assert(false);
  }
}

// 访问对应类型指令的函数定义略
// 视需求自行实现
// ...
```

#### 汇编分析（RISC-V）

生成汇编的思路和生成 Koopa IR 的思路类似, 都是遍历数据结构, 输出字符串. 此处不做过多赘述. 不过依然需要解释一下, RISC-V 汇编到底做了哪些事情.

在 SysY 程序中, 我们定义了一个 `main` 函数, 这个函数什么也没做, 只是返回了一个整数, 之后就退出了. RISC-V 程序所做的事情与之一致:

1. 定义了 `main` 函数.
2. 将作为返回值的整数加载到了存放返回值的寄存器中.
3. 执行返回指令.

所以:

- 如何定义函数?
  - 所谓函数, 从处理器的角度看只不过是一段指令序列. 调用函数时处理器跳转到序列的入口执行, 执行到序列中含义是 “函数返回” 的指令时, 处理器退出函数, 回到调用函数前的指令序列继续执行.
  - 在汇编层面 “定义” 函数, 其实只需要标注这个序列的入口在什么位置即可, 其余函数返回之类的操作都属于函数内的指令要完成的事情.
- RISC-V 中如何设置返回值?
  - RISC-V 指令系统的 ABI 规定, 返回值应当被存入 `a0` 和 `a1` 寄存器中. RV32I 下, 寄存器宽度为 32 位, 所以用寄存器可以传递两个 32 位的返回值.
  - 在编译实践涉及的所有情况下, 函数的返回值只有 32 位. 所以我们在传递返回值时, 只需要把数据放入 `a0` 寄存器即可.
- 如何将整数加载到寄存器中?
  - RISC-V 的汇编器支持 `li` 伪指令. 这条伪指令的作用是加载立即数 (**l**oad **i**mmediate) 到指定的寄存器中.

##### ABI

ABI Application Binary Interface是编译器和链接器遵守的一组规则，以让编译后的程序可以正常工作。ABI里包含很多方面的内容：

- ABI 最大和最重要的部分是规定函数的调用顺序，也称为“调用约定”。调用约定标准化了如何将“函数”转换为汇编代码。
- ABI 还规定了库中公开函数的name（如printf）应该如何表示，以便在链接后可以正确的调用这些库函数并接收参数。
- ABI 还规定可以使用什么类型的数据类型、它们必须如何对齐以及其他低级细节。
- 此外，ABI还涉及操作系统的内容，如可执行文件的格式，虚拟地址空间布局，还有Program Loading and Dynamic Linking等细节。

#### 有关risc-v的规范

 RISC-V 指令的官方定义,  [RISC-V 的规范](https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf). 编译实践中需要用到的 RISC-V 指令的相关定义 [RISC-V 指令速查](https://pku-minic.github.io/online-doc/#/misc-app-ref/riscv-insts)

## 6. Lv3: 表达式

能够处理一元/二元表达式：

```cpp
int main() {
  return 1 + 2 * -3;
}
```





## 7. Lv4: 常量和变量



## 8. Lv5: 语句块和作用域



## 9. Lv6: if语句



## 10. Lv7: while语句



## 11. Lv8: 函数和全局变量



## 12. Lv9: 数组



## 13. Lv10: 优化



